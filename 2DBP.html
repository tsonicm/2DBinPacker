<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Bin Packing Visualizer</title>
    <style>
        :root {
            --color-bg-primary: #f5f5f5;
            --color-text-primary: #1f2937;
            --color-text-secondary: #6b7280;
            --color-primary: #3b82f6;
            --color-primary-hover: #2563eb;
            --color-success: #10b981;
            --color-error: #ef4444;
            --color-border: #e5e7eb;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--color-bg-primary);
            color: var(--color-text-primary);
            padding: var(--spacing-md);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            font-size: 28px;
            margin-bottom: var(--spacing-md);
            color: var(--color-text-primary);
        }

        .layout {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: var(--spacing-lg);
            height: calc(100vh - 120px);
        }

        .panel {
            background: white;
            border-radius: 8px;
            border: 1px solid var(--color-border);
            padding: var(--spacing-lg);
        }

        .panel.scrollable {
            overflow-y: auto;
            max-height: 100%;
        }

        .panel.fixed {
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .section {
            margin-bottom: var(--spacing-lg);
        }

        .section h2 {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: var(--spacing-md);
            color: var(--color-text-primary);
        }

        .form-group {
            margin-bottom: var(--spacing-md);
        }

        label {
            display: block;
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 4px;
            color: var(--color-text-secondary);
        }

        input[type="number"],
        input[type="text"] {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--color-border);
            border-radius: 6px;
            font-size: 14px;
            font-family: inherit;
            transition: border-color 0.2s;
        }

        input[type="number"]:focus,
        input[type="text"]:focus {
            outline: none;
            border-color: var(--color-primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .button {
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }

        .button-primary {
            background: var(--color-primary);
            color: white;
            width: 100%;
            margin-bottom: var(--spacing-sm);
        }

        .button-primary:hover {
            background: var(--color-primary-hover);
        }

        .button-danger {
            background: var(--color-error);
            color: white;
            width: 100%;
        }

        .button-danger:hover {
            background: #dc2626;
        }

        .button-success {
            background: var(--color-success);
            color: white;
            width: 100%;
        }

        .button-success:hover {
            background: #059669;
        }

        .button-small {
            padding: 6px 12px;
            font-size: 12px;
        }

        .package-list {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid var(--color-border);
            border-radius: 6px;
        }

        .package-item {
            padding: var(--spacing-md);
            border-bottom: 1px solid var(--color-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
        }

        .package-item:last-child {
            border-bottom: none;
        }

        .package-info {
            flex: 1;
        }

        .package-id {
            font-weight: 600;
            color: var(--color-primary);
            margin-bottom: 2px;
        }

        .package-dims {
            color: var(--color-text-secondary);
            font-size: 12px;
        }

        .package-delete {
            background: var(--color-error);
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-left: var(--spacing-sm);
        }

        .package-delete:hover {
            background: #dc2626;
        }

        .bin-info {
            background: #f0f9ff;
            border: 1px solid #bfdbfe;
            border-radius: 6px;
            padding: var(--spacing-md);
            font-size: 13px;
            margin-bottom: var(--spacing-md);
        }

        .bin-info label {
            margin-bottom: 8px;
        }

        .canvas-container {
            background: white;
            border-radius: 8px;
            border: 1px solid var(--color-border);
            padding: var(--spacing-lg);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 600px;
        }

        #packingCanvas {
            border: 2px solid var(--color-border);
            background: #fafafa;
            cursor: crosshair;
        }

        .stats {
            background: #f0f9ff;
            border: 1px solid #bfdbfe;
            border-radius: 6px;
            padding: var(--color-primary);
            font-size: 13px;
            margin-top: var(--spacing-md);
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
        }

        .stat-label {
            color: var(--color-text-secondary);
        }

        .stat-value {
            font-weight: 600;
            color: var(--color-text-primary);
        }

        @media (max-width: 1024px) {
            .layout {
                grid-template-columns: 1fr;
            }

            .canvas-container {
                min-height: 400px;
            }
        }

        .color-legend {
            font-size: 12px;
            margin-top: var(--spacing-md);
            padding: var(--spacing-md);
            background: #f9fafb;
            border-radius: 6px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            margin-right: 8px;
        }

        .empty-state {
            color: var(--color-text-secondary);
            text-align: center;
            padding: var(--spacing-lg);
            font-size: 13px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>2D Bin Packing Visualizer</h1>

        <div class="layout">
            <!-- Left Panel: Input Controls -->
            <div class="panel scrollable">
                <!-- Bin Dimensions -->
                <div class="section">
                    <h2>Bin Dimensions (cm)</h2>
                    <div class="bin-info">
                        <div class="form-group">
                            <label for="binWidth">Width (cm)</label>
                            <input type="number" id="binWidth" min="1" value="100" />
                        </div>
                        <div class="form-group">
                            <label for="binHeight">Height (cm)</label>
                            <input type="number" id="binHeight" min="1" value="100" />
                        </div>
                    </div>
                </div>

                <!-- Add Package -->
                <div class="section">
                    <h2>Add Package (cm)</h2>
                    <div class="form-group">
                        <label for="packageRefNo">Reference Number (last 6 digits of EAN13)</label>
                        <input type="text" id="packageRefNo" placeholder="e.g., 123456" />
                    </div>
                    <div class="form-group">
                        <label for="packageLength">Length (cm)</label>
                        <input type="number" id="packageLength" min="0.1" step="0.1" placeholder="e.g., 50" />
                    </div>
                    <div class="form-group">
                        <label for="packageWidth">Width (cm)</label>
                        <input type="number" id="packageWidth" min="0.1" step="0.1" placeholder="e.g., 30" />
                    </div>
                    <div class="form-group">
                        <label for="packageComment">Comment (optional)</label>
                        <input type="text" id="packageComment" placeholder="e.g., Fragile" />
                    </div>
                    <div class="form-group">
                        <label for="packageClient">Client (optional)</label>
                        <input type="text" id="packageClient" placeholder="e.g., Client A" />
                    </div>
                    <button class="button button-primary" onclick="addPackage()">Add Package</button>
                    <button class="button button-danger" onclick="clearPackages()">Clear All</button>
                    
                    <div style="margin-top: var(--spacing-md); padding-top: var(--spacing-md); border-top: 1px solid var(--color-border);">
                        <label for="bulkPackages">Bulk Insert (refNo [tab] LxW [tab] comment [tab] client)</label>
                        <textarea id="bulkPackages" placeholder="123456&#9;50x30&#9;Fragile&#9;ClientA&#10;789012&#9;40*25&#9;&#9;ClientB&#10;345678&#9;60x35&#9;Heavy&#9;ClientA" style="width: 100%; padding: 8px 12px; border: 1px solid var(--color-border); border-radius: 6px; font-size: 13px; font-family: monospace; min-height: 80px; resize: vertical; margin-top: 4px;"></textarea>
                        <button class="button button-primary" onclick="bulkAddPackages()" style="margin-top: 8px;">Add from List</button>
                    </div>
                </div>

                <!-- Package List -->
                <div class="section">
                    <h2>Packages (<span id="packageCount">0</span>)</h2>
                    <div id="packageListContainer">
                        <div class="empty-state">No packages added yet</div>
                    </div>
                </div>

                <!-- Packing Button -->
                <div class="section">
                    <button class="button button-success" onclick="solvePacking()" style="font-size: 16px; padding: 12px;">Visualize Packing</button>
                    <button id="calculateSpaceBtn" class="button button-primary" onclick="toggleRemainingSpace()" style="font-size: 14px; padding: 10px; margin-top: 8px;" disabled>Show Remaining Space</button>
                </div>

                <!-- Export -->
                <div class="section">
                    <button class="button button-success" onclick="exportToPDF()" style="font-size: 14px; padding: 10px;">Export to PDF (A4)</button>
                </div>

                <!-- Statistics -->
                <div class="section">
                    <h2>Statistics</h2>
                    <div class="stats">
                        <div class="stat-row">
                            <span class="stat-label">Bin Area:</span>
                            <span class="stat-value" id="binArea">0</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Total Package Area:</span>
                            <span class="stat-value" id="totalPackageArea">0</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Utilization:</span>
                            <span class="stat-value" id="utilizationRate">0%</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Packages Packed:</span>
                            <span class="stat-value" id="packedCount">0</span>
                        </div>
                    </div>
                </div>

                <!-- Color Legend -->
                <div class="section">
                    <h2>Legend</h2>
                    <div class="color-legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #3b82f6;"></div>
                            <span>80cm Guide Lines (Height)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ef4444;"></div>
                            <span>2m Guide Lines (Width)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: linear-gradient(to right, #3b82f6, #10b981, #f59e0b, #ef4444);"></div>
                            <span>Packages (Color by Client)</span>
                        </div>
                        <div style="margin-top: var(--spacing-md); padding-top: var(--spacing-sm); border-top: 1px solid var(--color-border); font-size: 11px; color: var(--color-text-secondary);">
                            <div style="margin-bottom: 4px;"><strong>Placing Packages:</strong></div>
                            <div>• <strong>Alt/Option + Click:</strong> Place unpacked</div>
                            <div style="padding-left: 12px; color: #6b7280;">- Automatically finds best position</div>
                            <div style="padding-left: 12px; color: #6b7280;">- Click packages shown below bin</div>
                            
                            <div style="margin-top: 8px; margin-bottom: 4px;"><strong>Moving Packages:</strong></div>
                            <div>• Drag to move packages in bin</div>
                            <div>• <strong>Shift + Drag:</strong> Prevent overlap</div>
                            <div style="padding-left: 12px; color: #6b7280;">- Slides along obstacles</div>
                            
                            <div style="margin-top: 8px; margin-bottom: 4px;"><strong>Multi-Selection:</strong></div>
                            <div>• <strong>Ctrl/Cmd + Click:</strong> Select multiple</div>
                            <div style="padding-left: 12px; color: #6b7280;">- Selected packages highlighted in gold</div>
                            <div style="padding-left: 12px; color: #6b7280;">- Drag to move group together</div>
                            <div>• <strong>Esc:</strong> Clear selection</div>
                            
                            <div style="margin-top: 8px; margin-bottom: 4px;"><strong>Rotation:</strong></div>
                            <div>• Double-click to rotate package</div>
                            <div>• Press <strong>R</strong> key to rotate (on hover)</div>
                            
                            <div style="margin-top: 8px; margin-bottom: 4px;"><strong>View Controls:</strong></div>
                            <div>• Scroll to zoom (50%-500%)</div>
                            <div>• Drag empty space to pan</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Panel: Visualization -->
            <div class="panel fixed">
                <h2 style="padding: 0 var(--spacing-lg); padding-top: var(--spacing-lg);">Packing Visualization</h2>
                <div class="canvas-container" style="position: relative; flex: 1; overflow: hidden; padding: var(--spacing-lg);">
                    <div class="canvas-wrapper" id="canvasWrapper" style="position: relative; width: 100%; height: 100%; overflow: hidden;">
                        <canvas id="packingCanvas" style="display: block; width: 100%; height: 100%;"></canvas>
                    </div>
                    <div class="zoom-controls" style="position: absolute; bottom: 20px; right: 20px; background: white; border: 1px solid var(--color-border); border-radius: 8px; padding: 12px; z-index: 10; display: flex; gap: 8px; align-items: center; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <button class="zoom-button" onclick="zoomOut()" style="padding: 8px 12px; background: var(--color-primary); color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">−</button>
                        <div class="zoom-info" style="text-align: center; min-width: 80px;">
                            <span id="zoomLevel" style="display: block; font-weight: 600;">100%</span>
                            <small style="color: var(--color-text-secondary); font-size: 11px;">Use scroll</small>
                        </div>
                        <button class="zoom-button" onclick="zoomIn()" style="padding: 8px 12px; background: var(--color-primary); color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">+</button>
                        <button class="zoom-button" onclick="resetZoom()" style="padding: 8px 12px; background: var(--color-primary); color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">Reset</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script>
        // State
        let packages = [];
        let packedPackages = [];
        let packageIdCounter = 0;
        
        // Zoom and Pan state
        let zoomLevel = 1;
        let panX = 0;
        let panY = 0;
        const minZoom = 0.5;
        const maxZoom = 5;
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;
        
        // Drag state for moving packages
        let isDraggingPackage = false;
        let draggedPackageIndex = -1;
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        let hoveredPackageIndex = -1;
        let isShiftPressed = false;
        let isCtrlPressed = false;
        
        // Multi-selection state
        let selectedPackages = []; // Array of indices of selected packages
        let groupDragOffsets = []; // Relative positions of each package in the group
        let isAltPressed = false; // Alt/Option key for placing unpacked packages
        let showRemainingSpace = false; // Toggle for showing remaining space measurements
        
        // Client color mapping
        const clientColors = [
            '#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6',
            '#ec4899', '#06b6d4', '#84cc16', '#f97316', '#6366f1'
        ];
        let clientColorMap = {};
        
        // Get color for a client
        function getClientColor(client) {
            if (!client) return '#3b82f6'; // Default color
            if (!clientColorMap[client]) {
                const usedColors = Object.values(clientColorMap);
                const availableColor = clientColors.find(c => !usedColors.includes(c)) || clientColors[Object.keys(clientColorMap).length % clientColors.length];
                clientColorMap[client] = availableColor;
            }
            return clientColorMap[client];
        }

        // Helper: Extract and format reference number from EAN13
        function formatRefNo(input) {
            if (!input) return '';
            // Extract last 6 digits
            const digits = input.replace(/\D/g, '').slice(-6);
            // Trim leading zeros
            return digits.replace(/^0+/, '') || '0';
        }

        // Helper: Get padding based on standard package size
        // Standard sizes: 50, 60, 70, 77, 90, 100, 110, 117
        // 77 and 117 use 3cm padding, all others use 5cm padding
        function getPadding(size) {
            return (size === 77 || size === 117) ? 3 : 5;
        }

        // Helper: Convert cm to pixels for canvas
        function cmToPixels(cm, canvasSize = 400) {
            const binCm = Math.max(
                parseFloat(document.getElementById('binWidth').value),
                parseFloat(document.getElementById('binHeight').value)
            );
            return (cm / binCm) * canvasSize;
        }

        // Add a package to the list
        function addPackage() {
            const refNoInput = document.getElementById('packageRefNo').value;
            const length = parseFloat(document.getElementById('packageLength').value);
            const width = parseFloat(document.getElementById('packageWidth').value);
            const comment = document.getElementById('packageComment').value.trim();
            const client = document.getElementById('packageClient').value.trim();

            if (!length || !width || length <= 0 || width <= 0) {
                alert('Please enter valid dimensions');
                return;
            }

            const refNo = formatRefNo(refNoInput);
            if (!refNo) {
                alert('Please enter a valid reference number');
                return;
            }

            const lengthPadding = getPadding(length);
            const widthPadding = getPadding(width);

            packages.push({
                id: packageIdCounter++,
                refNo: refNo,
                length: length + lengthPadding,
                width: width + widthPadding,
                comment: comment,
                client: client
            });

            document.getElementById('packageRefNo').value = '';
            document.getElementById('packageLength').value = '';
            document.getElementById('packageWidth').value = '';
            document.getElementById('packageComment').value = '';
            document.getElementById('packageClient').value = '';
            updatePackageList();
            updateStatistics();
        }
        
        // Bulk add packages from textarea
        function bulkAddPackages() {
            const bulkText = document.getElementById('bulkPackages').value.trim();
            if (!bulkText) {
                alert('Please enter package data');
                return;
            }
            
            const lines = bulkText.split('\n');
            let addedCount = 0;
            let errorCount = 0;
            
            lines.forEach((line, index) => {
                line = line.trim();
                if (!line) return; // Skip empty lines
                
                // Split by tab first
                const parts = line.split('\t').map(p => p.trim()).filter(p => p);
                
                if (parts.length >= 2) {
                    const refNoInput = parts[0];
                    const dimString = parts[1];
                    const comment = parts.length >= 3 ? parts[2] : '';
                    const client = parts.length >= 4 ? parts[3].trim() : '';
                    
                    // Parse dimensions (support x or *)
                    const dimMatch = dimString.match(/([\d.]+)\s*[x*]\s*([\d.]+)/i);
                    
                    if (dimMatch) {
                        const length = parseFloat(dimMatch[1]);
                        const width = parseFloat(dimMatch[2]);
                        const refNo = formatRefNo(refNoInput);
                        
                        if (refNo && length > 0 && width > 0) {
                            const lengthPadding = getPadding(length);
                            const widthPadding = getPadding(width);
                            
                            packages.push({
                                id: packageIdCounter++,
                                refNo: refNo,
                                length: length + lengthPadding,
                                width: width + widthPadding,
                                comment: comment,
                                client: client
                            });
                            addedCount++;
                        } else {
                            errorCount++;
                        }
                    } else {
                        errorCount++;
                    }
                } else {
                    errorCount++;
                }
            });
            
            document.getElementById('bulkPackages').value = '';
            updatePackageList();
            updateStatistics();
            
            if (addedCount > 0) {
                alert(`Added ${addedCount} package(s)` + (errorCount > 0 ? `. ${errorCount} line(s) had errors and were skipped.` : ''));
            } else if (errorCount > 0) {
                alert('No valid packages found. Format: refNo [tab] LxW [tab] comment [tab] client (one per line)');
            }
        }

        // Remove a package
        function removePackage(id) {
            packages = packages.filter(p => p.id !== id);
            updatePackageList();
            updateStatistics();
        }

        // Edit a package
        function editPackage(id) {
            const pkg = packages.find(p => p.id === id);
            if (!pkg) return;

            // Create a formatted prompt with all fields
            const currentValues = `RefNo: ${pkg.refNo}\nLength: ${pkg.length}\nWidth: ${pkg.width}\nComment: ${pkg.comment || ''}\nClient: ${pkg.client || ''}`;
            const instructions = 'Edit package (format: refNo, length, width, comment, client)';
            const defaultValue = `${pkg.refNo}, ${pkg.length}, ${pkg.width}, ${pkg.comment || ''}, ${pkg.client || ''}`;
            
            const input = prompt(`${instructions}\n\nCurrent values:\n${currentValues}\n\nEnter new values (comma-separated):`, defaultValue);
            
            if (input === null) return; // Cancelled

            // Parse the input
            const parts = input.split(',').map(p => p.trim());
            
            if (parts.length < 3) {
                alert('Invalid format. Please enter: refNo, length, width, comment, client (comment and client are optional)');
                return;
            }

            const newRefNo = parts[0];
            const newLength = parts[1];
            const newWidth = parts[2];
            const newComment = parts.length >= 4 ? parts[3].trim() : '';
            const newClient = parts.length >= 5 ? parts.slice(4).join(',').trim() : '';

            const formattedRefNo = formatRefNo(newRefNo);
            const parsedLength = parseFloat(newLength);
            const parsedWidth = parseFloat(newWidth);

            if (!formattedRefNo || !parsedLength || !parsedWidth || parsedLength <= 0 || parsedWidth <= 0) {
                alert('Invalid values entered. Package not updated.');
                return;
            }

            const lengthPadding = getPadding(parsedLength);
            const widthPadding = getPadding(parsedWidth);

            pkg.refNo = formattedRefNo;
            pkg.length = parsedLength + lengthPadding;
            pkg.width = parsedWidth + widthPadding;
            pkg.comment = newComment;
            pkg.client = newClient;

            updatePackageList();
            updateStatistics();
        }

        // Clear all packages
        function clearPackages() {
            packages = [];
            packedPackages = [];
            packageIdCounter = 0;
            selectedPackages = []; // Clear selection
            updatePackageList();
            updateStatistics();
            clearCanvas();
        }

        // Update the package list display
        function updatePackageList() {
            const container = document.getElementById('packageListContainer');
            document.getElementById('packageCount').textContent = packages.length;

            if (packages.length === 0) {
                container.innerHTML = '<div class="empty-state">No packages added yet</div>';
                return;
            }

            container.innerHTML = packages.map(pkg => `
                <div class="package-item">
                    <div style="display: flex; align-items: center; gap: 8px; flex: 1;">
                        ${pkg.client ? `<div style="width: 12px; height: 12px; border-radius: 2px; background: ${getClientColor(pkg.client)}; flex-shrink: 0;"></div>` : ''}
                        <div class="package-info">
                            <div class="package-id">${pkg.refNo || 'N/A'}${pkg.client ? ` (${pkg.client})` : ''}</div>
                            <div class="package-dims">${Math.round(pkg.length)}×${Math.round(pkg.width)}</div>
                            ${pkg.comment ? `<div class="package-dims" style="color: #3b82f6; margin-top: 2px;">${pkg.comment}</div>` : ''}
                        </div>
                    </div>
                    <div style="display: flex; gap: 4px;">
                        <button class="package-delete" onclick="editPackage(${pkg.id})" style="background: var(--color-primary);">Edit</button>
                        <button class="package-delete" onclick="removePackage(${pkg.id})">Delete</button>
                    </div>
                </div>
            `).join('');
        }

        // Update statistics
        function updateStatistics() {
            const binWidth = parseFloat(document.getElementById('binWidth').value) || 0;
            const binHeight = parseFloat(document.getElementById('binHeight').value) || 0;
            const binArea = binWidth * binHeight;

            const totalPackageArea = packages.reduce((sum, pkg) => {
                const pkgCm2 = pkg.length * pkg.width;
                return sum + pkgCm2;
            }, 0);

            const utilization = binArea > 0 ? ((totalPackageArea / binArea) * 100) : 0;

            // Format areas - use m² if >= 10000 cm² (1 m²)
            let binAreaText, packageAreaText;
            if (binArea >= 10000) {
                binAreaText = `${(binArea / 10000).toFixed(2)} m²`;
            } else {
                binAreaText = `${Math.round(binArea)} cm²`;
            }
            
            if (totalPackageArea >= 10000) {
                packageAreaText = `${(totalPackageArea / 10000).toFixed(2)} m²`;
            } else {
                packageAreaText = `${Math.round(totalPackageArea)} cm²`;
            }

            document.getElementById('binArea').textContent = binAreaText;
            document.getElementById('totalPackageArea').textContent = packageAreaText;
            document.getElementById('utilizationRate').textContent = `${utilization.toFixed(1)}%`;
            document.getElementById('packedCount').textContent = packedPackages.length;
        }

        // 2D Bin Packing Algorithm (Maximal Rectangles with Strict Client Clustering)
        function packItems() {
            const binWidth = parseFloat(document.getElementById('binWidth').value);
            const binHeight = parseFloat(document.getElementById('binHeight').value);

            if (!binWidth || !binHeight || packages.length === 0) {
                return [];
            }

            // Group packages by client
            const clientGroups = {};
            packages.forEach(pkg => {
                const clientKey = pkg.client || '_no_client';
                if (!clientGroups[clientKey]) {
                    clientGroups[clientKey] = [];
                }
                clientGroups[clientKey].push({
                    id: pkg.id,
                    refNo: pkg.refNo,
                    w: pkg.length,
                    h: pkg.width,
                    client: pkg.client,
                    comment: pkg.comment
                });
            });

            // Sort each group by constraint factor (most constrained first)
            // Packages close to bin dimensions are most constraining and should go first
            Object.values(clientGroups).forEach(group => {
                group.sort((a, b) => {
                    // Calculate how constraining each package is
                    const constraintA = Math.max(
                        Math.min(a.w / binWidth, a.h / binHeight),
                        Math.min(a.h / binWidth, a.w / binHeight)
                    );
                    const constraintB = Math.max(
                        Math.min(b.w / binWidth, b.h / binHeight),
                        Math.min(b.h / binWidth, b.w / binHeight)
                    );
                    
                    // If constraint factors are similar, sort by area
                    if (Math.abs(constraintA - constraintB) < 0.1) {
                        return (b.w * b.h) - (a.w * a.h);
                    }
                    
                    return constraintB - constraintA;
                });
            });
            
            // Sort client groups by total area (largest clients first)
            const clientKeys = Object.keys(clientGroups).sort((a, b) => {
                const areaA = clientGroups[a].reduce((sum, pkg) => sum + (pkg.w * pkg.h), 0);
                const areaB = clientGroups[b].reduce((sum, pkg) => sum + (pkg.w * pkg.h), 0);
                return areaB - areaA;
            });

            const result = [];
            // Global free rectangles - start with the entire bin
            const globalFreeRects = [{ x: 0, y: 0, w: binWidth, h: binHeight }];
            
            // Process each client group completely before moving to the next
            clientKeys.forEach(clientKey => {
                const itemsForPacking = clientGroups[clientKey];
                const clientPackages = []; // Track packages placed for this client
                const clientFreeRects = [...globalFreeRects.map(r => ({...r}))] // Deep copy for this client

                // Pack each item in this client group
                itemsForPacking.forEach((item, itemIndex) => {
                    let bestPlacement = null;
                    let bestScore = -Infinity;

                    // Sort free rectangles to prioritize those adjacent to current client cluster
                    if (clientPackages.length > 0) {
                        clientFreeRects.sort((a, b) => {
                            const distA = getMinDistanceToCluster(a, clientPackages);
                            const distB = getMinDistanceToCluster(b, clientPackages);
                            
                            // Primary: sort by distance to cluster
                            if (Math.abs(distA - distB) > 5) {
                                return distA - distB;
                            }
                            
                            // Secondary: prefer rectangles with better fit potential (smaller area)
                            const areaA = a.w * a.h;
                            const areaB = b.w * b.h;
                            if (Math.abs(areaA - areaB) > 100) {
                                return areaA - areaB;
                            }
                            
                            // Tertiary: prefer top-left as final tie-breaker
                            if (Math.abs(a.y - b.y) > 5) {
                                return a.y - b.y;
                            }
                            return a.x - b.x;
                        });
                    } else {
                        // For first package, prefer smaller rectangles with top-left bias
                        clientFreeRects.sort((a, b) => {
                            const areaA = a.w * a.h;
                            const areaB = b.w * b.h;
                            if (Math.abs(areaA - areaB) > 100) {
                                return areaA - areaB;
                            }
                            if (Math.abs(a.y - b.y) > 5) {
                                return a.y - b.y;
                            }
                            return a.x - b.x;
                        });
                    }

                    // Evaluate all possible placements
                    for (let i = 0; i < clientFreeRects.length; i++) {
                        const rect = clientFreeRects[i];

                        // Try normal orientation
                        if (item.w <= rect.w && item.h <= rect.h) {
                            const score = evaluateClientPlacement(rect, item, false, clientPackages, itemIndex === 0, binWidth, binHeight, clientFreeRects, item.w, item.h);
                            if (score > bestScore) {
                                bestPlacement = {
                                    rect: rect,
                                    rectIndex: i,
                                    rotated: false,
                                    x: rect.x,
                                    y: rect.y,
                                    w: item.w,
                                    h: item.h
                                };
                                bestScore = score;
                            }
                        }

                        // Try rotated orientation
                        if (item.h <= rect.w && item.w <= rect.h) {
                            const score = evaluateClientPlacement(rect, item, true, clientPackages, itemIndex === 0, binWidth, binHeight, clientFreeRects, item.h, item.w);
                            if (score > bestScore) {
                                bestPlacement = {
                                    rect: rect,
                                    rectIndex: i,
                                    rotated: true,
                                    x: rect.x,
                                    y: rect.y,
                                    w: item.h,
                                    h: item.w
                                };
                                bestScore = score;
                            }
                        }
                    }

                    // If we found a place, insert the item
                    if (bestPlacement) {
                        const newItem = {
                            id: item.id,
                            refNo: item.refNo,
                            client: item.client,
                            comment: item.comment,
                            x: bestPlacement.x,
                            y: bestPlacement.y,
                            w: bestPlacement.w,
                            h: bestPlacement.h
                        };
                        result.push(newItem);
                        clientPackages.push(newItem);

                        // Maximal Rectangles: Split all overlapping free rectangles
                        splitFreeRectangles(clientFreeRects, newItem);
                        
                        // Remove redundant rectangles
                        pruneAndMergeFreeRects(clientFreeRects);
                    }
                });
                
                // After placing all packages for this client, update global free space
                clientPackages.forEach(pkg => {
                    splitFreeRectangles(globalFreeRects, pkg);
                    pruneAndMergeFreeRects(globalFreeRects);
                });
            });

            return result;
        }

        // Calculate minimum distance from a free rectangle to a cluster of packages
        function getMinDistanceToCluster(rect, cluster) {
            if (cluster.length === 0) return 0;
            
            let minDist = Infinity;
            cluster.forEach(pkg => {
                // Calculate distance between rectangle centers
                const rectCenterX = rect.x + rect.w / 2;
                const rectCenterY = rect.y + rect.h / 2;
                const pkgCenterX = pkg.x + pkg.w / 2;
                const pkgCenterY = pkg.y + pkg.h / 2;
                
                // Check if they touch (distance = 0)
                const touchesLeft = Math.abs(rect.x - (pkg.x + pkg.w)) < 0.1;
                const touchesRight = Math.abs(rect.x + rect.w - pkg.x) < 0.1;
                const touchesTop = Math.abs(rect.y - (pkg.y + pkg.h)) < 0.1;
                const touchesBottom = Math.abs(rect.y + rect.h - pkg.y) < 0.1;
                
                if ((touchesLeft || touchesRight) && rect.y < pkg.y + pkg.h && rect.y + rect.h > pkg.y) {
                    return 0;
                }
                if ((touchesTop || touchesBottom) && rect.x < pkg.x + pkg.w && rect.x + rect.w > pkg.x) {
                    return 0;
                }
                
                // Calculate edge-to-edge distance
                const dx = Math.max(0, Math.max(rect.x - (pkg.x + pkg.w), pkg.x - (rect.x + rect.w)));
                const dy = Math.max(0, Math.max(rect.y - (pkg.y + pkg.h), pkg.y - (rect.y + rect.h)));
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                minDist = Math.min(minDist, distance);
            });
            
            return minDist;
        }

        // Evaluate placement quality for client clustering
        function evaluateClientPlacement(rect, item, rotated, clientPackages, isFirstItem, binWidth, binHeight, allFreeRects, w, h) {
            // w and h are already the dimensions after rotation
            
            // Calculate leftover space (Best Short Side Fit)
            const leftoverHoriz = rect.w - w;
            const leftoverVert = rect.h - h;
            const shortSideFit = Math.min(leftoverHoriz, leftoverVert);
            const longSideFit = Math.max(leftoverHoriz, leftoverVert);
            
            // Base score: prefer tight fits (this is the PRIMARY criterion)
            let score = 100000 - (shortSideFit * 100 + longSideFit * 10);
            
            // CRITICAL: Heavily penalize orientations that create unusably narrow spaces
            const minUsableSpace = 30; // Minimum usable space in cm
            
            // Check if this placement would create narrow unusable strips
            if (shortSideFit > 0 && shortSideFit < minUsableSpace) {
                // This creates a strip too narrow to use - heavy penalty
                score -= 50000 * (minUsableSpace - shortSideFit);
            }
            
            // Additional penalty if the package takes up most of a dimension
            // leaving a sliver that's hard to use
            const heightRatio = h / rect.h;
            const widthRatio = w / rect.w;
            
            if (heightRatio > 0.85 && leftoverVert < minUsableSpace && leftoverVert > 0) {
                // Takes up most of the height, leaving narrow bottom strip
                score -= 100000;
            }
            if (widthRatio > 0.85 && leftoverHoriz < minUsableSpace && leftoverHoriz > 0) {
                // Takes up most of the width, leaving narrow right strip  
                score -= 100000;
            }
            
            // Secondary preference for top-left positions (much lighter weight)
            // This acts as a tie-breaker when fits are similar
            score -= rect.y * 1;   // Light penalty for lower positions
            score -= rect.x * 0.5; // Very light penalty for rightward positions
            
            // For first item of client, use top-left + best fit
            if (isFirstItem || clientPackages.length === 0) {
                return score;
            }
            
            // For subsequent items, HEAVILY prioritize adjacency to same client
            let maxTouching = 0;
            let minDistance = Infinity;
            
            // The package will be placed at rect.x, rect.y with dimensions w, h
            const pkgX = rect.x;
            const pkgY = rect.y;
            const pkgRight = pkgX + w;
            const pkgBottom = pkgY + h;
            
            clientPackages.forEach(placed => {
                const placedRight = placed.x + placed.w;
                const placedBottom = placed.y + placed.h;
                
                // Calculate touching length for each side
                let touching = 0;
                
                // Left side: package's left edge touches placed package's right edge
                if (Math.abs(pkgX - placedRight) < 0.1) {
                    const overlapStart = Math.max(pkgY, placed.y);
                    const overlapEnd = Math.min(pkgBottom, placedBottom);
                    if (overlapEnd > overlapStart) {
                        touching = Math.max(touching, overlapEnd - overlapStart);
                    }
                }
                
                // Right side: package's right edge touches placed package's left edge
                if (Math.abs(pkgRight - placed.x) < 0.1) {
                    const overlapStart = Math.max(pkgY, placed.y);
                    const overlapEnd = Math.min(pkgBottom, placedBottom);
                    if (overlapEnd > overlapStart) {
                        touching = Math.max(touching, overlapEnd - overlapStart);
                    }
                }
                
                // Top side: package's top edge touches placed package's bottom edge
                if (Math.abs(pkgY - placedBottom) < 0.1) {
                    const overlapStart = Math.max(pkgX, placed.x);
                    const overlapEnd = Math.min(pkgRight, placedRight);
                    if (overlapEnd > overlapStart) {
                        touching = Math.max(touching, overlapEnd - overlapStart);
                    }
                }
                
                // Bottom side: package's bottom edge touches placed package's top edge
                if (Math.abs(pkgBottom - placed.y) < 0.1) {
                    const overlapStart = Math.max(pkgX, placed.x);
                    const overlapEnd = Math.min(pkgRight, placedRight);
                    if (overlapEnd > overlapStart) {
                        touching = Math.max(touching, overlapEnd - overlapStart);
                    }
                }
                
                maxTouching = Math.max(maxTouching, touching);
                
                // Calculate minimum distance if not touching
                if (touching === 0) {
                    const dx = Math.max(0, Math.max(pkgX - placedRight, placed.x - pkgRight));
                    const dy = Math.max(0, Math.max(pkgY - placedBottom, placed.y - pkgBottom));
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    minDistance = Math.min(minDistance, distance);
                }
            });
            
            // MASSIVE bonus for touching same-client packages
            if (maxTouching > 0) {
                // More touching length = better score
                // Strong adjacency bonus to keep clients clustered
                score += 5000000 + maxTouching * 5000;
            } else {
                // If not touching, heavily penalize but still allow with distance penalty
                score -= 10000000 + minDistance * 10000;
            }
            
            return score;
        }

        // Split free rectangles using Maximal Rectangles subdivision
        function splitFreeRectangles(freeRects, placedRect) {
            const newRects = [];
            
            for (let i = freeRects.length - 1; i >= 0; i--) {
                const rect = freeRects[i];
                
                // Check if the placed rectangle overlaps with this free rectangle
                if (!rectanglesOverlap(placedRect, rect)) {
                    continue;
                }
                
                // Remove the overlapping rectangle and create new ones from the remaining space
                freeRects.splice(i, 1);
                
                // Generate new rectangles from the non-overlapping parts
                // Left side
                if (rect.x < placedRect.x) {
                    newRects.push({
                        x: rect.x,
                        y: rect.y,
                        w: placedRect.x - rect.x,
                        h: rect.h
                    });
                }
                
                // Right side
                if (rect.x + rect.w > placedRect.x + placedRect.w) {
                    newRects.push({
                        x: placedRect.x + placedRect.w,
                        y: rect.y,
                        w: rect.x + rect.w - (placedRect.x + placedRect.w),
                        h: rect.h
                    });
                }
                
                // Top side
                if (rect.y < placedRect.y) {
                    newRects.push({
                        x: rect.x,
                        y: rect.y,
                        w: rect.w,
                        h: placedRect.y - rect.y
                    });
                }
                
                // Bottom side
                if (rect.y + rect.h > placedRect.y + placedRect.h) {
                    newRects.push({
                        x: rect.x,
                        y: placedRect.y + placedRect.h,
                        w: rect.w,
                        h: rect.y + rect.h - (placedRect.y + placedRect.h)
                    });
                }
            }
            
            // Add all new rectangles to the free list
            freeRects.push(...newRects);
        }

        // Helper function to remove redundant free rectangles and merge adjacent ones
        function pruneAndMergeFreeRects(freeRects) {
            // Remove rectangles that are completely inside other rectangles
            for (let i = freeRects.length - 1; i >= 0; i--) {
                for (let j = freeRects.length - 1; j >= 0; j--) {
                    if (i !== j && i < freeRects.length) {
                        if (isRectInsideRect(freeRects[i], freeRects[j])) {
                            freeRects.splice(i, 1);
                            break;
                        }
                    }
                }
            }
            
            // Merge adjacent rectangles to create larger free spaces
            let merged = true;
            while (merged) {
                merged = false;
                for (let i = 0; i < freeRects.length && !merged; i++) {
                    for (let j = i + 1; j < freeRects.length && !merged; j++) {
                        const rect1 = freeRects[i];
                        const rect2 = freeRects[j];
                        
                        // Check if rectangles can be merged horizontally
                        if (rect1.y === rect2.y && rect1.h === rect2.h) {
                            if (rect1.x + rect1.w === rect2.x) {
                                // rect2 is directly to the right of rect1
                                rect1.w += rect2.w;
                                freeRects.splice(j, 1);
                                merged = true;
                            } else if (rect2.x + rect2.w === rect1.x) {
                                // rect1 is directly to the right of rect2
                                rect2.w += rect1.w;
                                freeRects.splice(i, 1);
                                merged = true;
                            }
                        }
                        
                        // Check if rectangles can be merged vertically
                        if (rect1.x === rect2.x && rect1.w === rect2.w) {
                            if (rect1.y + rect1.h === rect2.y) {
                                // rect2 is directly below rect1
                                rect1.h += rect2.h;
                                freeRects.splice(j, 1);
                                merged = true;
                            } else if (rect2.y + rect2.h === rect1.y) {
                                // rect1 is directly below rect2
                                rect2.h += rect1.h;
                                freeRects.splice(i, 1);
                                merged = true;
                            }
                        }
                    }
                }
            }
        }

        // Check if rect1 is completely inside rect2
        function isRectInsideRect(rect1, rect2) {
            return rect1.x >= rect2.x &&
                   rect1.y >= rect2.y &&
                   rect1.x + rect1.w <= rect2.x + rect2.w &&
                   rect1.y + rect1.h <= rect2.y + rect2.h;
        }

        // Find closest valid position for a package
        function findClosestValidPosition(targetX, targetY, w, h, excludeIndex) {
            const binWidth = parseFloat(document.getElementById('binWidth').value);
            const binHeight = parseFloat(document.getElementById('binHeight').value);
            
            // If target position is valid, return it
            if (!wouldOverlap(targetX, targetY, w, h, excludeIndex)) {
                return { x: targetX, y: targetY, found: true };
            }
            
            // Search in expanding circles around the target position
            const maxSearchRadius = 150; // cm
            const step = 2; // cm - smaller step for more precise searching
            let bestDistance = Infinity;
            let bestX = targetX;
            let bestY = targetY;
            let found = false;
            
            // Search through ALL radii to find the absolute closest position
            for (let radius = step; radius <= maxSearchRadius; radius += step) {
                const positions = [];
                
                // Sample positions around the circle
                const samples = Math.max(16, Math.ceil(radius / 3));
                for (let i = 0; i < samples; i++) {
                    const angle = (i / samples) * Math.PI * 2;
                    const testX = targetX + Math.cos(angle) * radius;
                    const testY = targetY + Math.sin(angle) * radius;
                    
                    // Clamp to bin boundaries
                    const clampedX = Math.max(0, Math.min(testX, binWidth - w));
                    const clampedY = Math.max(0, Math.min(testY, binHeight - h));
                    
                    positions.push({ x: clampedX, y: clampedY });
                }
                
                // Check each position
                for (const pos of positions) {
                    if (pos.x >= 0 && pos.y >= 0 && pos.x + w <= binWidth && pos.y + h <= binHeight) {
                        if (!wouldOverlap(pos.x, pos.y, w, h, excludeIndex)) {
                            const distance = Math.sqrt(
                                Math.pow(pos.x - targetX, 2) + 
                                Math.pow(pos.y - targetY, 2)
                            );
                            if (distance < bestDistance) {
                                bestDistance = distance;
                                bestX = pos.x;
                                bestY = pos.y;
                                found = true;
                            }
                        }
                    }
                }
                
                // Continue searching all radii to ensure we find the absolute closest position
            }
            
            return { x: bestX, y: bestY, found: found };
        }

        // Check if two rectangles overlap
        function rectanglesOverlap(rect1, rect2) {
            return !(rect1.x + rect1.w <= rect2.x ||
                     rect2.x + rect2.w <= rect1.x ||
                     rect1.y + rect1.h <= rect2.y ||
                     rect2.y + rect2.h <= rect1.y);
        }

        // Check if package at given position would overlap with other packages
        function wouldOverlap(x, y, w, h, excludeIndex) {
            const testRect = { x, y, w, h };
            for (let i = 0; i < packedPackages.length; i++) {
                if (i === excludeIndex) continue;
                const pkg = packedPackages[i];
                const pkgRect = { x: pkg.x, y: pkg.y, w: pkg.w, h: pkg.h };
                if (rectanglesOverlap(testRect, pkgRect)) {
                    return true;
                }
            }
            return false;
        }
        
        // Check if group of packages would overlap with other packages
        function wouldGroupOverlap(packagePositions, excludeIndices) {
            const excludeSet = new Set(excludeIndices);
            
            // Check each package in the group against all non-group packages
            for (const testPkg of packagePositions) {
                const testRect = { x: testPkg.x, y: testPkg.y, w: testPkg.w, h: testPkg.h };
                for (let i = 0; i < packedPackages.length; i++) {
                    if (excludeSet.has(i)) continue;
                    const pkg = packedPackages[i];
                    const pkgRect = { x: pkg.x, y: pkg.y, w: pkg.w, h: pkg.h };
                    if (rectanglesOverlap(testRect, pkgRect)) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        // Get package at mouse position
        function getPackageAtPosition(mouseX, mouseY, offsetX, offsetY, basePixelPerCm) {
            // Adjust for zoom and pan
            const adjustedX = (mouseX - panX) / zoomLevel;
            const adjustedY = (mouseY - panY) / zoomLevel;
            
            // Check each packed package (in reverse to prioritize top packages)
            for (let i = packedPackages.length - 1; i >= 0; i--) {
                const pkg = packedPackages[i];
                const pkgX = offsetX + pkg.x * basePixelPerCm;
                const pkgY = offsetY + pkg.y * basePixelPerCm;
                const pkgW = pkg.w * basePixelPerCm;
                const pkgH = pkg.h * basePixelPerCm;
                
                if (adjustedX >= pkgX && adjustedX <= pkgX + pkgW &&
                    adjustedY >= pkgY && adjustedY <= pkgY + pkgH) {
                    return i;
                }
            }
            return -1;
        }
        
        // Get unpacked package at mouse position
        function getUnpackedPackageAtPosition(mouseX, mouseY, offsetX, offsetY, basePixelPerCm, binHeight, binWidth, unpackedPackages) {
            // Adjust for zoom and pan
            const adjustedX = (mouseX - panX) / zoomLevel;
            const adjustedY = (mouseY - panY) / zoomLevel;
            
            const pixelHeight = binHeight * basePixelPerCm;
            const pixelWidth = binWidth * basePixelPerCm;
            const unpackedStartY = offsetY + pixelHeight + 40 / zoomLevel;
            const packageSpacing = 10 / zoomLevel;
            const maxPackageHeight = 60 / zoomLevel;
            const maxPackageWidth = 100 / zoomLevel;
            
            let currentX = offsetX;
            let currentY = unpackedStartY;
            let rowHeight = 0;
            
            for (let i = 0; i < unpackedPackages.length; i++) {
                const pkg = unpackedPackages[i];
                const pkgW = Math.min(pkg.length * basePixelPerCm, maxPackageWidth);
                const pkgH = Math.min(pkg.width * basePixelPerCm, maxPackageHeight);
                
                // Check if package fits in current row, if not wrap to next row
                if (currentX + pkgW > offsetX + pixelWidth && currentX > offsetX) {
                    currentX = offsetX;
                    currentY += rowHeight + packageSpacing;
                    rowHeight = 0;
                }
                
                // Track the tallest package in this row
                rowHeight = Math.max(rowHeight, pkgH);
                
                if (adjustedX >= currentX && adjustedX <= currentX + pkgW &&
                    adjustedY >= currentY && adjustedY <= currentY + pkgH) {
                    return i;
                }
                
                currentX += pkgW + packageSpacing;
            }
            return -1;
        }
        
        // Find a suitable position for a package in the bin
        function findSuitablePosition(pkg) {
            const binWidth = parseFloat(document.getElementById('binWidth').value);
            const binHeight = parseFloat(document.getElementById('binHeight').value);
            
            // Try common positions first: top-left, bottom-left, top-right
            const testPositions = [
                { x: 0, y: 0 },
                { x: 0, y: binHeight - pkg.h },
                { x: binWidth - pkg.w, y: 0 },
                { x: binWidth - pkg.w, y: binHeight - pkg.h }
            ];
            
            // Test common positions
            for (const pos of testPositions) {
                if (pos.x >= 0 && pos.y >= 0 && pos.x + pkg.w <= binWidth && pos.y + pkg.h <= binHeight) {
                    if (!wouldOverlap(pos.x, pos.y, pkg.w, pkg.h, -1)) {
                        return pos;
                    }
                }
            }
            
            // Grid search for a valid position
            const step = 5; // cm
            for (let y = 0; y <= binHeight - pkg.h; y += step) {
                for (let x = 0; x <= binWidth - pkg.w; x += step) {
                    if (!wouldOverlap(x, y, pkg.w, pkg.h, -1)) {
                        return { x, y };
                    }
                }
            }
            
            // Try rotated
            if (pkg.w !== pkg.h) {
                const rotatedW = pkg.h;
                const rotatedH = pkg.w;
                for (let y = 0; y <= binHeight - rotatedH; y += step) {
                    for (let x = 0; x <= binWidth - rotatedW; x += step) {
                        if (!wouldOverlap(x, y, rotatedW, rotatedH, -1)) {
                            return { x, y, rotated: true };
                        }
                    }
                }
            }
            
            return null;
        }
        
        // Rotate a package 90 degrees
        function rotatePackage(index) {
            if (index < 0 || index >= packedPackages.length) return;
            
            const pkg = packedPackages[index];
            const binWidth = parseFloat(document.getElementById('binWidth').value);
            const binHeight = parseFloat(document.getElementById('binHeight').value);
            
            // Swap width and height
            const newW = pkg.h;
            const newH = pkg.w;
            
            // Check if rotated package still fits in bin at current position
            if (pkg.x + newW <= binWidth && pkg.y + newH <= binHeight) {
                pkg.w = newW;
                pkg.h = newH;
                drawPacking();
            } else {
                // Try to adjust position to fit
                let newX = pkg.x;
                let newY = pkg.y;
                
                if (pkg.x + newW > binWidth) {
                    newX = binWidth - newW;
                }
                if (pkg.y + newH > binHeight) {
                    newY = binHeight - newH;
                }
                
                // Only rotate if it fits after adjustment
                if (newX >= 0 && newY >= 0) {
                    pkg.w = newW;
                    pkg.h = newH;
                    pkg.x = newX;
                    pkg.y = newY;
                    drawPacking();
                } else {
                    alert('Package cannot be rotated - it would not fit in the bin');
                }
            }
        }

        // Solve and visualize
        function solvePacking() {
            if (packages.length === 0) {
                alert('Please add at least one package');
                return;
            }

            packedPackages = packItems();
            selectedPackages = []; // Clear selection when repacking
            showRemainingSpace = false; // Reset the toggle
            document.getElementById('calculateSpaceBtn').textContent = 'Show Remaining Space';
            drawPacking();

            // Update packed count
            document.getElementById('packedCount').textContent = packedPackages.length;
            
            // Enable the calculate space button
            document.getElementById('calculateSpaceBtn').disabled = false;
        }
        
        // Toggle remaining space visualization
        function toggleRemainingSpace() {
            showRemainingSpace = !showRemainingSpace;
            const btn = document.getElementById('calculateSpaceBtn');
            btn.textContent = showRemainingSpace ? 'Hide Remaining Space' : 'Show Remaining Space';
            drawPacking();
        }
        
        // Find rightmost packages (packages that don't have another package to their right)
        function findRightmostPackages() {
            const binWidth = parseFloat(document.getElementById('binWidth').value);
            const rightmostPackages = [];
            
            // For each package, check if there's another package to its right
            packedPackages.forEach((pkg, index) => {
                let hasPackageToRight = false;
                const pkgRightEdge = pkg.x + pkg.w;
                
                // Check if any other package starts within or after this package's right edge
                // and overlaps vertically
                for (let i = 0; i < packedPackages.length; i++) {
                    if (i === index) continue;
                    const otherPkg = packedPackages[i];
                    
                    // Check if other package is to the right (starts after this package's left edge)
                    if (otherPkg.x >= pkg.x + 0.1) { // Small tolerance for floating point
                        // Check vertical overlap
                        const verticalOverlap = !(pkg.y + pkg.h <= otherPkg.y || otherPkg.y + otherPkg.h <= pkg.y);
                        if (verticalOverlap) {
                            hasPackageToRight = true;
                            break;
                        }
                    }
                }
                
                // If no package to the right and there's space remaining
                if (!hasPackageToRight && pkgRightEdge < binWidth - 0.1) {
                    rightmostPackages.push({
                        index: index,
                        pkg: pkg,
                        remainingSpace: binWidth - pkgRightEdge
                    });
                }
            });
            
            return rightmostPackages;
        }

        // Draw the packing visualization
        function drawPacking() {
            const canvas = document.getElementById('packingCanvas');
            const wrapper = document.getElementById('canvasWrapper');
            const ctx = canvas.getContext('2d');

            const binWidth = parseFloat(document.getElementById('binWidth').value);
            const binHeight = parseFloat(document.getElementById('binHeight').value);

            // Get available space in the container
            const containerWidth = wrapper.clientWidth;
            const containerHeight = wrapper.clientHeight;
            
            // Calculate margins
            const margin = 80;
            const availableWidth = containerWidth - margin;
            const availableHeight = containerHeight - margin;
            
            // Calculate scale to fit the bin in available space
            const scaleX = availableWidth / binWidth;
            const scaleY = availableHeight / binHeight;
            const basePixelPerCm = Math.min(scaleX, scaleY, 30); // Cap at 30 for very small bins
            
            const pixelWidth = binWidth * basePixelPerCm;
            const pixelHeight = binHeight * basePixelPerCm;

            // Set canvas size to match container
            canvas.width = containerWidth;
            canvas.height = containerHeight;
            
            // Center the bin in the canvas
            const offsetX = (containerWidth - pixelWidth - margin) / 2 + margin / 2;
            const offsetY = (containerHeight - pixelHeight - margin) / 2 + margin / 2;

            // Apply zoom and pan transformation
            ctx.save();
            ctx.translate(panX, panY);
            ctx.scale(zoomLevel, zoomLevel);

            // Background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw bin border
            ctx.strokeStyle = '#1f2937';
            ctx.lineWidth = 2 / zoomLevel;
            ctx.strokeRect(offsetX, offsetY, pixelWidth, pixelHeight);

            // Draw grid
            ctx.strokeStyle = '#e5e7eb';
            ctx.lineWidth = 0.5 / zoomLevel;
            const gridStep = 10 * basePixelPerCm;
            for (let i = 0; i <= binWidth; i += 10) {
                const x = offsetX + (i * basePixelPerCm);
                ctx.beginPath();
                ctx.moveTo(x, offsetY);
                ctx.lineTo(x, offsetY + pixelHeight);
                ctx.stroke();
            }
            for (let i = 0; i <= binHeight; i += 10) {
                const y = offsetY + (i * basePixelPerCm);
                ctx.beginPath();
                ctx.moveTo(offsetX, y);
                ctx.lineTo(offsetX + pixelWidth, y);
                ctx.stroke();
            }

            // Draw 80cm indicators for height/length (dotted)
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 1.5 / zoomLevel;
            ctx.setLineDash([5 / zoomLevel, 5 / zoomLevel]);
            for (let i = 80; i <= binHeight; i += 80) {
                // Skip if within 10cm of the border
                if (binHeight - i < 10) continue;
                
                const y = offsetY + (i * basePixelPerCm);
                ctx.beginPath();
                ctx.moveTo(offsetX, y);
                ctx.lineTo(offsetX + pixelWidth, y);
                ctx.stroke();
            }
            
            // Draw 2m (200cm) indicators for width only (dotted)
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 2 / zoomLevel;
            ctx.setLineDash([5 / zoomLevel, 5 / zoomLevel]);
            for (let i = 200; i <= binWidth; i += 200) {
                const x = offsetX + (i * basePixelPerCm);
                ctx.beginPath();
                ctx.moveTo(x, offsetY);
                ctx.lineTo(x, offsetY + pixelHeight);
                ctx.stroke();
                
                // Label
                ctx.fillStyle = '#ef4444';
                ctx.font = `bold ${10 / zoomLevel}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText(`${i/100}`, x, offsetY - 5 / zoomLevel);
            }
            
            // Reset line dash for subsequent drawing
            ctx.setLineDash([]);
            
            // Draw horizontal axis: 0m marker at start (top)
            ctx.strokeStyle = '#000000';
            ctx.fillStyle = '#000000';
            ctx.lineWidth = 1.5 / zoomLevel;
            ctx.font = `bold ${12 / zoomLevel}px Arial`;
            ctx.textAlign = 'center';
            // Vertical tick at 0m
            ctx.beginPath();
            ctx.moveTo(offsetX, offsetY - 5 / zoomLevel);
            ctx.lineTo(offsetX, offsetY);
            ctx.stroke();
            ctx.fillText('0m', offsetX, offsetY - 10 / zoomLevel);
            
            // Horizontal axis: final length marker at end (top)
            const finalLengthMeters = (binWidth / 100).toFixed(2);
            // Vertical tick at final length
            ctx.beginPath();
            ctx.moveTo(offsetX + pixelWidth, offsetY - 5 / zoomLevel);
            ctx.lineTo(offsetX + pixelWidth, offsetY);
            ctx.stroke();
            ctx.fillText(`${finalLengthMeters}m`, offsetX + pixelWidth, offsetY - 10 / zoomLevel);

            // Draw packed items
            packedPackages.forEach((item, index) => {
                const x = offsetX + item.x * basePixelPerCm;
                const y = offsetY + item.y * basePixelPerCm;
                const width = item.w * basePixelPerCm;
                const height = item.h * basePixelPerCm;

                // Get client-specific color
                const clientColor = getClientColor(item.client);
                
                // Background
                ctx.fillStyle = clientColor;
                ctx.fillRect(x, y, width, height);

                // Border - show selection with glowing border
                const isSelected = selectedPackages.includes(index);
                if (isSelected) {
                    // Glowing selection border
                    ctx.strokeStyle = '#fbbf24'; // Yellow/orange glow
                    ctx.lineWidth = 4 / zoomLevel;
                    ctx.strokeRect(x, y, width, height);
                    
                    // Inner border
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2 / zoomLevel;
                    ctx.strokeRect(x, y, width, height);
                } else {
                    // Normal border - darker version of the same color
                    const darkerColor = adjustBrightness(clientColor, -30);
                    ctx.strokeStyle = darkerColor;
                    ctx.lineWidth = 2 / zoomLevel;
                    ctx.strokeRect(x, y, width, height);
                }

                // Calculate dynamic font size based on package size and zoom
                const minDim = Math.min(width, height);
                const baseFontSize = Math.min(14, minDim / 3);
                // At high zoom levels, don't scale font down as much
                const zoomAdjustment = zoomLevel > 2 ? Math.max(0.5, 1 / Math.sqrt(zoomLevel)) : 1 / zoomLevel;
                const scaledFontSize = Math.max(8, baseFontSize * zoomAdjustment);

                // Package Reference Number
                ctx.fillStyle = '#ffffff';
                ctx.font = `bold ${scaledFontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(item.refNo || `#${item.id}`, x + width / 2, y + height / 2 - scaledFontSize / 2);

                // Dimensions label
                ctx.fillStyle = '#ffffff';
                ctx.font = `${scaledFontSize * 0.8}px Arial`;
                const dimText = `${Math.round(item.w)}×${Math.round(item.h)}`;
                ctx.fillText(dimText, x + width / 2, y + height / 2 + scaledFontSize / 2);
            });

            // Draw unpacked items as visual packages below the bin
            const unpackedPackages = packages.filter(p => !packedPackages.find(item => item.id === p.id));

            if (unpackedPackages.length > 0) {
                const unpackedStartY = offsetY + pixelHeight + 40 / zoomLevel;
                let currentX = offsetX;
                let currentY = unpackedStartY;
                const packageSpacing = 10 / zoomLevel;
                const maxPackageHeight = 60 / zoomLevel;
                const maxPackageWidth = 100 / zoomLevel;
                let rowHeight = 0;
                
                // Label
                ctx.fillStyle = '#6b7280';
                ctx.font = `bold ${12 / zoomLevel}px Arial`;
                ctx.textAlign = 'left';
                ctx.fillText('Unpacked Packages (Alt+Click to place):', offsetX, offsetY + pixelHeight + 30 / zoomLevel);
                
                // Draw each unpacked package with wrapping
                unpackedPackages.forEach((pkg) => {
                    const displayW = Math.min(pkg.length * basePixelPerCm, maxPackageWidth);
                    const displayH = Math.min(pkg.width * basePixelPerCm, maxPackageHeight);
                    
                    // Check if package fits in current row, if not wrap to next row
                    if (currentX + displayW > offsetX + pixelWidth && currentX > offsetX) {
                        currentX = offsetX;
                        currentY += rowHeight + packageSpacing;
                        rowHeight = 0;
                    }
                    
                    // Track the tallest package in this row
                    rowHeight = Math.max(rowHeight, displayH);
                    
                    // Get client-specific color
                    const clientColor = getClientColor(pkg.client);
                    
                    // Background with semi-transparency to indicate unpacked
                    ctx.globalAlpha = 0.7;
                    ctx.fillStyle = clientColor;
                    ctx.fillRect(currentX, currentY, displayW, displayH);
                    ctx.globalAlpha = 1.0;
                    
                    // Border
                    const darkerColor = adjustBrightness(clientColor, -30);
                    ctx.strokeStyle = darkerColor;
                    ctx.lineWidth = 2 / zoomLevel;
                    ctx.strokeRect(currentX, currentY, displayW, displayH);
                    
                    // Text
                    ctx.fillStyle = '#ffffff';
                    const fontSize = Math.min(10 / zoomLevel, displayH / 3);
                    ctx.font = `bold ${fontSize}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(pkg.refNo || `#${pkg.id}`, currentX + displayW / 2, currentY + displayH / 2 - fontSize / 2);
                    
                    // Dimensions
                    ctx.font = `${fontSize}px Arial`;
                    const dimText = `${Math.round(pkg.length)}×${Math.round(pkg.width)}`;
                    ctx.fillText(dimText, currentX + displayW / 2, currentY + displayH / 2 + fontSize / 2);
                    
                    currentX += displayW + packageSpacing;
                });
            }
            
            // Draw remaining space measurements if enabled
            if (showRemainingSpace && packedPackages.length > 0) {
                const rightmostPackages = findRightmostPackages();
                
                ctx.strokeStyle = '#10b981'; // Green color
                ctx.fillStyle = '#10b981';
                ctx.lineWidth = 2 / zoomLevel;
                ctx.setLineDash([5 / zoomLevel, 3 / zoomLevel]);
                ctx.font = `bold ${11 / zoomLevel}px Arial`;
                ctx.textAlign = 'center';
                
                rightmostPackages.forEach(item => {
                    const pkg = item.pkg;
                    const pkgRightEdge = offsetX + (pkg.x + pkg.w) * basePixelPerCm;
                    const binRightEdge = offsetX + pixelWidth;
                    const pkgY = offsetY + pkg.y * basePixelPerCm;
                    const pkgH = pkg.h * basePixelPerCm;
                    const midY = pkgY + pkgH / 2;
                    
                    // Draw horizontal line
                    ctx.beginPath();
                    ctx.moveTo(pkgRightEdge, midY);
                    ctx.lineTo(binRightEdge, midY);
                    ctx.stroke();
                    
                    // Draw end caps
                    const capHeight = 8 / zoomLevel;
                    ctx.setLineDash([]);
                    ctx.beginPath();
                    ctx.moveTo(pkgRightEdge, midY - capHeight);
                    ctx.lineTo(pkgRightEdge, midY + capHeight);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(binRightEdge, midY - capHeight);
                    ctx.lineTo(binRightEdge, midY + capHeight);
                    ctx.stroke();
                    
                    // Draw measurement text
                    const textX = (pkgRightEdge + binRightEdge) / 2;
                    const textY = midY - 6 / zoomLevel;
                    
                    // Background for text
                    ctx.fillStyle = '#ffffff';
                    ctx.globalAlpha = 0.9;
                    const spaceText = `${item.remainingSpace.toFixed(1)} cm`;
                    const textWidth = ctx.measureText(spaceText).width;
                    ctx.fillRect(textX - textWidth / 2 - 3 / zoomLevel, textY - 10 / zoomLevel, textWidth + 6 / zoomLevel, 14 / zoomLevel);
                    ctx.globalAlpha = 1.0;
                    
                    // Text
                    ctx.fillStyle = '#10b981';
                    ctx.fillText(spaceText, textX, textY);
                    
                    ctx.setLineDash([5 / zoomLevel, 3 / zoomLevel]);
                });
                
                ctx.setLineDash([]);
            }

            // Draw axis labels
            ctx.fillStyle = '#6b7280';
            ctx.font = `${12 / zoomLevel}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText(`${binWidth} cm`, offsetX + pixelWidth / 2, offsetY + pixelHeight + 10);

            ctx.save();
            ctx.translate(offsetX - 25, offsetY + pixelHeight / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillText(`${binHeight} cm`, 0, 0);
            ctx.restore();

            ctx.restore();
        }

        // Helper: Adjust color brightness
        function adjustBrightness(hex, percent) {
            const num = parseInt(hex.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.max(0, Math.min(255, (num >> 16) + amt));
            const G = Math.max(0, Math.min(255, (num >> 8 & 0x00FF) + amt));
            const B = Math.max(0, Math.min(255, (num & 0x0000FF) + amt));
            return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }

        // Clear canvas
        function clearCanvas() {
            const canvas = document.getElementById('packingCanvas');
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // Zoom functions
        function zoomIn() {
            zoomLevel = Math.min(zoomLevel * 1.2, maxZoom);
            updateZoomLevel();
            drawPacking();
        }

        function zoomOut() {
            zoomLevel = Math.max(zoomLevel / 1.2, minZoom);
            updateZoomLevel();
            drawPacking();
        }

        function resetZoom() {
            zoomLevel = 1;
            panX = 0;
            panY = 0;
            updateZoomLevel();
            drawPacking();
        }

        function updateZoomLevel() {
            document.getElementById('zoomLevel').textContent = Math.round(zoomLevel * 100) + '%';
        }

        // Pan and Zoom with mouse
        const wrapper = document.getElementById('canvasWrapper');
        const canvas = document.getElementById('packingCanvas');

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Get drawing parameters
            const binWidth = parseFloat(document.getElementById('binWidth').value);
            const binHeight = parseFloat(document.getElementById('binHeight').value);
            const containerWidth = wrapper.clientWidth;
            const containerHeight = wrapper.clientHeight;
            const margin = 80;
            const availableWidth = containerWidth - margin;
            const availableHeight = containerHeight - margin;
            const scaleX = availableWidth / binWidth;
            const scaleY = availableHeight / binHeight;
            const basePixelPerCm = Math.min(scaleX, scaleY, 30);
            const pixelWidth = binWidth * basePixelPerCm;
            const pixelHeight = binHeight * basePixelPerCm;
            const offsetX = (containerWidth - pixelWidth - margin) / 2 + margin / 2;
            const offsetY = (containerHeight - pixelHeight - margin) / 2 + margin / 2;
            
            // Check if Alt+clicking on an unpacked package
            const unpackedPackages = packages.filter(p => !packedPackages.find(item => item.id === p.id));
            if (isAltPressed && unpackedPackages.length > 0) {
                const unpackedIndex = getUnpackedPackageAtPosition(mouseX, mouseY, offsetX, offsetY, basePixelPerCm, binHeight, binWidth, unpackedPackages);
                if (unpackedIndex >= 0) {
                    const pkg = unpackedPackages[unpackedIndex];
                    const position = findSuitablePosition({ w: pkg.length, h: pkg.width });
                    
                    if (position) {
                        // Add to packed packages
                        packedPackages.push({
                            id: pkg.id,
                            refNo: pkg.refNo,
                            x: position.x,
                            y: position.y,
                            w: position.rotated ? pkg.width : pkg.length,
                            h: position.rotated ? pkg.length : pkg.width,
                            client: pkg.client,
                            comment: pkg.comment
                        });
                        document.getElementById('packedCount').textContent = packedPackages.length;
                        drawPacking();
                    } else {
                        alert('Cannot find a suitable position for this package in the bin');
                    }
                    return;
                }
            }
            
            if (packedPackages.length === 0) return;
            
            // Check if clicking on a package
            const pkgIndex = getPackageAtPosition(mouseX, mouseY, offsetX, offsetY, basePixelPerCm);
            
            if (pkgIndex >= 0) {
                // Handle Ctrl/Cmd+click for multi-selection
                if (isCtrlPressed) {
                    const selectedIndex = selectedPackages.indexOf(pkgIndex);
                    if (selectedIndex >= 0) {
                        // Deselect if already selected
                        selectedPackages.splice(selectedIndex, 1);
                    } else {
                        // Add to selection
                        selectedPackages.push(pkgIndex);
                    }
                    drawPacking();
                    return;
                }
                
                // If clicking on a non-selected package and multiple are selected, clear selection
                if (selectedPackages.length > 0 && !selectedPackages.includes(pkgIndex)) {
                    selectedPackages = [];
                }
                
                // If no selection, make this the only selected package
                if (selectedPackages.length === 0) {
                    selectedPackages = [pkgIndex];
                }
                
                // Start dragging package(s)
                isDraggingPackage = true;
                draggedPackageIndex = pkgIndex;
                
                // Calculate offsets for all selected packages
                const adjustedX = (mouseX - panX) / zoomLevel;
                const adjustedY = (mouseY - panY) / zoomLevel;
                const clickedPkg = packedPackages[pkgIndex];
                const clickedPkgX = offsetX + clickedPkg.x * basePixelPerCm;
                const clickedPkgY = offsetY + clickedPkg.y * basePixelPerCm;
                
                dragOffsetX = adjustedX - clickedPkgX;
                dragOffsetY = adjustedY - clickedPkgY;
                
                // Store relative positions of all packages in the selection
                groupDragOffsets = selectedPackages.map(idx => {
                    const pkg = packedPackages[idx];
                    return {
                        index: idx,
                        offsetX: pkg.x - clickedPkg.x,
                        offsetY: pkg.y - clickedPkg.y
                    };
                });
                
                canvas.style.cursor = 'move';
            } else {
                // Clicked on empty space - clear selection and start panning
                selectedPackages = [];
                drawPacking();
                isPanning = true;
                panStartX = e.clientX - panX;
                panStartY = e.clientY - panY;
                canvas.style.cursor = 'grabbing';
            }
        });
        
        // Double-click to rotate package
        canvas.addEventListener('dblclick', (e) => {
            if (packedPackages.length === 0) return;
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const binWidth = parseFloat(document.getElementById('binWidth').value);
            const binHeight = parseFloat(document.getElementById('binHeight').value);
            const containerWidth = wrapper.clientWidth;
            const containerHeight = wrapper.clientHeight;
            const margin = 80;
            const availableWidth = containerWidth - margin;
            const availableHeight = containerHeight - margin;
            const scaleX = availableWidth / binWidth;
            const scaleY = availableHeight / binHeight;
            const basePixelPerCm = Math.min(scaleX, scaleY, 30);
            const pixelWidth = binWidth * basePixelPerCm;
            const pixelHeight = binHeight * basePixelPerCm;
            const offsetX = (containerWidth - pixelWidth - margin) / 2 + margin / 2;
            const offsetY = (containerHeight - pixelHeight - margin) / 2 + margin / 2;
            
            const pkgIndex = getPackageAtPosition(mouseX, mouseY, offsetX, offsetY, basePixelPerCm);
            if (pkgIndex >= 0) {
                rotatePackage(pkgIndex);
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isDraggingPackage && draggedPackageIndex >= 0) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Get drawing parameters
                const binWidth = parseFloat(document.getElementById('binWidth').value);
                const binHeight = parseFloat(document.getElementById('binHeight').value);
                const containerWidth = wrapper.clientWidth;
                const containerHeight = wrapper.clientHeight;
                const margin = 80;
                const availableWidth = containerWidth - margin;
                const availableHeight = containerHeight - margin;
                const scaleX = availableWidth / binWidth;
                const scaleY = availableHeight / binHeight;
                const basePixelPerCm = Math.min(scaleX, scaleY, 30);
                const pixelWidth = binWidth * basePixelPerCm;
                const pixelHeight = binHeight * basePixelPerCm;
                const offsetX = (containerWidth - pixelWidth - margin) / 2 + margin / 2;
                const offsetY = (containerHeight - pixelHeight - margin) / 2 + margin / 2;
                
                // Update package position(s)
                const adjustedX = (mouseX - panX) / zoomLevel;
                const adjustedY = (mouseY - panY) / zoomLevel;
                
                // Calculate new position for the primary dragged package in cm
                let newX = (adjustedX - offsetX - dragOffsetX) / basePixelPerCm;
                let newY = (adjustedY - offsetY - dragOffsetY) / basePixelPerCm;
                
                if (selectedPackages.length > 1) {
                    // Multi-package drag
                    // Calculate new positions for all packages in the group
                    const newPositions = groupDragOffsets.map(offset => {
                        const pkg = packedPackages[offset.index];
                        return {
                            index: offset.index,
                            x: newX + offset.offsetX,
                            y: newY + offset.offsetY,
                            w: pkg.w,
                            h: pkg.h
                        };
                    });
                    
                    // Find bounds of the group to clamp to bin boundaries
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    newPositions.forEach(pos => {
                        minX = Math.min(minX, pos.x);
                        minY = Math.min(minY, pos.y);
                        maxX = Math.max(maxX, pos.x + pos.w);
                        maxY = Math.max(maxY, pos.y + pos.h);
                    });
                    
                    // Clamp group to bin boundaries
                    let clampOffsetX = 0, clampOffsetY = 0;
                    if (minX < 0) clampOffsetX = -minX;
                    if (minY < 0) clampOffsetY = -minY;
                    if (maxX > binWidth) clampOffsetX = binWidth - maxX;
                    if (maxY > binHeight) clampOffsetY = binHeight - maxY;
                    
                    // Apply clamping to all positions
                    newPositions.forEach(pos => {
                        pos.x += clampOffsetX;
                        pos.y += clampOffsetY;
                    });
                    
                    // Check for overlap if Shift is pressed
                    if (isShiftPressed) {
                        // Try full movement first
                        if (!wouldGroupOverlap(newPositions, selectedPackages)) {
                            newPositions.forEach(pos => {
                                packedPackages[pos.index].x = pos.x;
                                packedPackages[pos.index].y = pos.y;
                            });
                        } else {
                            // Try sliding on X axis only
                            const xOnlyPositions = groupDragOffsets.map(offset => {
                                const pkg = packedPackages[offset.index];
                                return {
                                    index: offset.index,
                                    x: newX + offset.offsetX + clampOffsetX,
                                    y: pkg.y,
                                    w: pkg.w,
                                    h: pkg.h
                                };
                            });
                            
                            let movedX = false;
                            if (!wouldGroupOverlap(xOnlyPositions, selectedPackages)) {
                                xOnlyPositions.forEach(pos => {
                                    packedPackages[pos.index].x = pos.x;
                                });
                                movedX = true;
                            }
                            
                            // Try sliding on Y axis only
                            const yOnlyPositions = groupDragOffsets.map(offset => {
                                const pkg = packedPackages[offset.index];
                                return {
                                    index: offset.index,
                                    x: pkg.x,
                                    y: newY + offset.offsetY + clampOffsetY,
                                    w: pkg.w,
                                    h: pkg.h
                                };
                            });
                            
                            if (!wouldGroupOverlap(yOnlyPositions, selectedPackages)) {
                                yOnlyPositions.forEach(pos => {
                                    packedPackages[pos.index].y = pos.y;
                                });
                            }
                        }
                    } else {
                        // No collision prevention - just move
                        newPositions.forEach(pos => {
                            packedPackages[pos.index].x = pos.x;
                            packedPackages[pos.index].y = pos.y;
                        });
                    }
                } else {
                    // Single package drag (original behavior)
                    const pkg = packedPackages[draggedPackageIndex];
                    
                    // Clamp to bin boundaries
                    newX = Math.max(0, Math.min(newX, binWidth - pkg.w));
                    newY = Math.max(0, Math.min(newY, binHeight - pkg.h));
                    
                    // Check for overlap if Shift is pressed
                    if (isShiftPressed) {
                        // Try full movement first
                        if (!wouldOverlap(newX, newY, pkg.w, pkg.h, draggedPackageIndex)) {
                            pkg.x = newX;
                            pkg.y = newY;
                        } else {
                            // Try sliding along obstacles (one axis at a time)
                            let movedX = false;
                            let movedY = false;
                            
                            // Try moving only on X axis (keeping Y the same)
                            if (!wouldOverlap(newX, pkg.y, pkg.w, pkg.h, draggedPackageIndex)) {
                                pkg.x = newX;
                                movedX = true;
                            }
                            
                            // Try moving only on Y axis (keeping X the same or using new X if it worked)
                            const testX = movedX ? newX : pkg.x;
                            if (!wouldOverlap(testX, newY, pkg.w, pkg.h, draggedPackageIndex)) {
                                pkg.y = newY;
                                movedY = true;
                            }
                            
                            // Only snap to closest empty space if the current position is actually overlapping
                            // (not just blocked by walls on both sides)
                            if (!movedX && !movedY && wouldOverlap(pkg.x, pkg.y, pkg.w, pkg.h, draggedPackageIndex)) {
                                const snap = findClosestValidPosition(newX, newY, pkg.w, pkg.h, draggedPackageIndex);
                                if (snap.found) {
                                    pkg.x = snap.x;
                                    pkg.y = snap.y;
                                }
                            }
                            // If current position is valid and both axes are blocked, just stay in place
                        }
                    } else {
                        pkg.x = newX;
                        pkg.y = newY;
                    }
                }
                
                drawPacking();
            } else if (isPanning) {
                panX = e.clientX - panStartX;
                panY = e.clientY - panStartY;
                drawPacking();
            }
        });

        document.addEventListener('mouseup', () => {
            isDraggingPackage = false;
            draggedPackageIndex = -1;
            isPanning = false;
            canvas.style.cursor = 'crosshair';
        });

        canvas.addEventListener('mouseleave', () => {
            isDraggingPackage = false;
            draggedPackageIndex = -1;
            isPanning = false;
            canvas.style.cursor = 'crosshair';
        });
        
        // Update cursor on hover to show draggable packages
        canvas.addEventListener('mousemove', (e) => {
            if (!isDraggingPackage && !isPanning && packedPackages.length > 0) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                const binWidth = parseFloat(document.getElementById('binWidth').value);
                const binHeight = parseFloat(document.getElementById('binHeight').value);
                const containerWidth = wrapper.clientWidth;
                const containerHeight = wrapper.clientHeight;
                const margin = 80;
                const availableWidth = containerWidth - margin;
                const availableHeight = containerHeight - margin;
                const scaleX = availableWidth / binWidth;
                const scaleY = availableHeight / binHeight;
                const basePixelPerCm = Math.min(scaleX, scaleY, 30);
                const pixelWidth = binWidth * basePixelPerCm;
                const pixelHeight = binHeight * basePixelPerCm;
                const offsetX = (containerWidth - pixelWidth - margin) / 2 + margin / 2;
                const offsetY = (containerHeight - pixelHeight - margin) / 2 + margin / 2;
                
                const pkgIndex = getPackageAtPosition(mouseX, mouseY, offsetX, offsetY, basePixelPerCm);
                hoveredPackageIndex = pkgIndex;
                canvas.style.cursor = pkgIndex >= 0 ? 'move' : 'grab';
            }
        });
        
        // Keyboard handlers
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Shift') {
                isShiftPressed = true;
            }
            if (e.key === 'Control' || e.key === 'Meta') {  // Ctrl on Windows/Linux, Cmd on Mac
                isCtrlPressed = true;
            }
            if (e.key === 'Alt') {  // Alt/Option key
                isAltPressed = true;
                canvas.style.cursor = 'copy';
            }
            if (e.key === 'r' || e.key === 'R') {
                if (hoveredPackageIndex >= 0) {
                    rotatePackage(hoveredPackageIndex);
                }
            }
            if (e.key === 'Escape') {
                // Clear selection on Escape
                if (selectedPackages.length > 0) {
                    selectedPackages = [];
                    drawPacking();
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'Shift') {
                isShiftPressed = false;
            }
            if (e.key === 'Control' || e.key === 'Meta') {
                isCtrlPressed = false;
            }
            if (e.key === 'Alt') {
                isAltPressed = false;
                canvas.style.cursor = 'crosshair';
            }
        });

        // Mouse wheel zoom
        wrapper.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            zoomLevel = Math.max(minZoom, Math.min(maxZoom, zoomLevel * zoomFactor));
            updateZoomLevel();
            drawPacking();
        }, { passive: false });

        // Helper: Convert hex to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 59, g: 130, b: 246 };
        }

        // Export to PDF
        function exportToPDF() {
            if (packedPackages.length === 0) {
                alert('Please pack the items first before exporting');
                return;
            }

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({
                orientation: 'landscape',
                unit: 'mm',
                format: 'a4'
            });

            // A4 dimensions in mm (landscape)
            const pageWidth = 297;
            const pageHeight = 210;
            const margin = 15;
            const contentWidth = pageWidth - 2 * margin;
            const contentHeight = pageHeight - 2 * margin;

            // Title
            doc.setFontSize(16);
            doc.text('2D Bin Packing Result', margin, margin + 10);

            // Info
            const binWidth = parseFloat(document.getElementById('binWidth').value);
            const binHeight = parseFloat(document.getElementById('binHeight').value);
            doc.setFontSize(10);
            doc.text(`Bin Size: ${binWidth} cm × ${binHeight} cm`, margin, margin + 20);
            doc.text(`Packages Packed: ${packedPackages.length} / ${packages.length}`, margin, margin + 26);

            // Calculate scale
            const scale = Math.min(contentWidth / binWidth, (contentHeight - 40) / binHeight);
            const scaledWidth = binWidth * scale;
            const scaledHeight = binHeight * scale;
            const startX = margin + (contentWidth - scaledWidth) / 2;
            const startY = margin + 35;

            // Draw bin border
            doc.setDrawColor(0);
            doc.setLineWidth(0.5);
            doc.rect(startX, startY, scaledWidth, scaledHeight);

            // Draw 80cm indicators for height (dotted blue)
            doc.setDrawColor(59, 130, 246);
            doc.setLineWidth(0.3);
            doc.setLineDash([2, 2]);
            for (let i = 80; i <= binHeight; i += 80) {
                // Skip if within 10cm of the border
                if (binHeight - i < 10) continue;
                
                const y = startY + (i / binHeight) * scaledHeight;
                doc.line(startX, y, startX + scaledWidth, y);
            }

            // Draw 2m indicators for width (dotted red)
            doc.setDrawColor(239, 68, 68);
            doc.setLineWidth(0.4);
            doc.setLineDash([2, 2]);
            for (let i = 200; i <= binWidth; i += 200) {
                const x = startX + (i / binWidth) * scaledWidth;
                doc.line(x, startY, x, startY + scaledHeight);
                doc.setFontSize(7);
                doc.setTextColor(239, 68, 68);
                doc.text(`${i/100}`, x - 2, startY - 2);
            }
            
            // Reset line dash
            doc.setLineDash([]);
            
            // Draw horizontal axis: 0m marker at start (top)
            doc.setDrawColor(0);
            doc.setTextColor(0);
            doc.setFontSize(9);
            doc.setLineWidth(0.5);
            // Vertical tick at 0m
            doc.line(startX, startY - 3, startX, startY);
            doc.text('0m', startX - 2, startY - 5);
            
            // Horizontal axis: final length marker at end (top)
            const finalLengthMeters = (binWidth / 100).toFixed(2);
            // Vertical tick at final length
            doc.line(startX + scaledWidth, startY - 3, startX + scaledWidth, startY);
            doc.text(`${finalLengthMeters}m`, startX + scaledWidth - 5, startY - 5);

            // Draw packages
            doc.setLineWidth(0.3);
            packedPackages.forEach(item => {
                const x = startX + (item.x / binWidth) * scaledWidth;
                const y = startY + (item.y / binHeight) * scaledHeight;
                const w = (item.w / binWidth) * scaledWidth;
                const h = (item.h / binHeight) * scaledHeight;

                // Get client color
                const clientColor = getClientColor(item.client);
                const rgb = hexToRgb(clientColor);
                
                // Fill
                doc.setFillColor(rgb.r, rgb.g, rgb.b);
                doc.setDrawColor(Math.max(0, rgb.r - 50), Math.max(0, rgb.g - 50), Math.max(0, rgb.b - 50));
                doc.rect(x, y, w, h, 'FD');

                // Text
                doc.setTextColor(255, 255, 255);
                doc.setFontSize(Math.max(6, Math.min(10, Math.min(w, h) / 5)));
                doc.text(item.refNo || `#${item.id}`, x + w / 2, y + h / 2, { align: 'center' });
            });

            // Package list
            let listY = startY + scaledHeight + 10;
            if (listY + 20 < pageHeight - margin) {
                doc.setTextColor(0);
                doc.setFontSize(12);
                doc.text('Package List:', margin, listY);
                listY += 6;

                doc.setFontSize(8);
                packedPackages.forEach((item, index) => {
                    if (listY > pageHeight - margin - 5) {
                        doc.addPage();
                        listY = margin + 10;
                    }
                    const clientText = item.client ? ` [${item.client}]` : '';
                    const text = `${item.refNo || '#' + item.id}${clientText}: ${Math.round(item.w)} × ${Math.round(item.h)} cm${item.comment ? ' - ' + item.comment : ''}`;
                    doc.text(text, margin, listY);
                    listY += 5;
                });
            }

            // Save
            doc.save('bin-packing-result.pdf');
        }

        // Resize handler for dynamic sizing
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (packedPackages.length > 0) {
                    drawPacking();
                }
            }, 100);
        });

        // Initialize
        updatePackageList();
        updateStatistics();
        clearCanvas();
        updateZoomLevel();

        // Handle Enter key for adding packages
        document.getElementById('packageWidth').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') addPackage();
        });
    </script>
</parameter>
</body>
</html>
